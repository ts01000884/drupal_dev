'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _events = require('events');

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _mustache = require('mustache');

var _mustache2 = _interopRequireDefault(_mustache);

var _lodash = require('lodash');

var _useragent = require('useragent');

var _readFileRelative = require('read-file-relative');

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _nanoid = require('nanoid');

var _nanoid2 = _interopRequireDefault(_nanoid);

var _command = require('./command');

var _command2 = _interopRequireDefault(_command);

var _status = require('./status');

var _status2 = _interopRequireDefault(_status);

var _runtime = require('../../errors/runtime');

var _message = require('../../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const IDLE_PAGE_TEMPLATE = (0, _readFileRelative.readSync)('../../client/browser/idle-page/index.html.mustache');

var connections = {};

class BrowserConnection extends _events.EventEmitter {
    constructor(gateway, browserInfo, permanent) {
        super();

        this.HEARTBEAT_TIMEOUT = 2 * 60 * 1000;

        this.id = BrowserConnection._generateId();
        this.jobQueue = [];
        this.initScriptsQueue = [];
        this.browserConnectionGateway = gateway;

        this.browserInfo = browserInfo;
        this.browserInfo.userAgent = '';
        this.browserInfo.userAgentProviderMetaInfo = '';

        this.provider = browserInfo.provider;

        this.permanent = permanent;
        this.closing = false;
        this.closed = false;
        this.ready = false;
        this.opened = false;
        this.idle = true;
        this.heartbeatTimeout = null;
        this.pendingTestRunUrl = null;

        this.url = `${gateway.domain}/browser/connect/${this.id}`;
        this.idleUrl = `${gateway.domain}/browser/idle/${this.id}`;
        this.forcedIdleUrl = `${gateway.domain}/browser/idle-forced/${this.id}`;
        this.initScriptUrl = `${gateway.domain}/browser/init-script/${this.id}`;

        this.heartbeatRelativeUrl = `/browser/heartbeat/${this.id}`;
        this.statusRelativeUrl = `/browser/status/${this.id}`;
        this.statusDoneRelativeUrl = `/browser/status-done/${this.id}`;

        this.heartbeatUrl = `${gateway.domain}${this.heartbeatRelativeUrl}`;
        this.statusUrl = `${gateway.domain}${this.statusRelativeUrl}`;
        this.statusDoneUrl = `${gateway.domain}${this.statusDoneRelativeUrl}`;

        this.on('error', () => {
            this._forceIdle();
            this.close();
        });

        connections[this.id] = this;

        this.browserConnectionGateway.startServingConnection(this);

        this._runBrowser();
    }

    static _generateId() {
        return (0, _nanoid2.default)(7);
    }

    _runBrowser() {
        var _this = this;

        // NOTE: Give caller time to assign event listeners
        process.nextTick((0, _asyncToGenerator3.default)(function* () {
            try {
                yield _this.provider.openBrowser(_this.id, _this.url, _this.browserInfo.browserName);

                if (!_this.ready) yield (0, _promisifyEvent2.default)(_this, 'ready');

                _this.opened = true;
                _this.emit('opened');
            } catch (err) {
                _this.emit('error', new _runtime.GeneralError(_message2.default.unableToOpenBrowser, _this.browserInfo.providerName + ':' + _this.browserInfo.browserName, err.stack));
            }
        }));
    }

    _closeBrowser() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (!_this2.idle) yield (0, _promisifyEvent2.default)(_this2, 'idle');

            try {
                yield _this2.provider.closeBrowser(_this2.id);
            } catch (err) {
                // NOTE: A warning would be really nice here, but it can't be done while log is stored in a task.
            }
        })();
    }

    _forceIdle() {
        if (!this.idle) {
            this.switchingToIdle = false;
            this.idle = true;
            this.emit('idle');
        }
    }

    _waitForHeartbeat() {
        this.heartbeatTimeout = setTimeout(() => {
            this.emit('error', new _runtime.GeneralError(_message2.default.browserDisconnected, this.userAgent));
        }, this.HEARTBEAT_TIMEOUT);
    }

    _getTestRunUrl(isTestDone) {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (isTestDone || !_this3.pendingTestRunUrl) _this3.pendingTestRunUrl = yield _this3._popNextTestRunUrl();

            return _this3.pendingTestRunUrl;
        })();
    }

    _popNextTestRunUrl() {
        var _this4 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            while (_this4.hasQueuedJobs && !_this4.currentJob.hasQueuedTestRuns) _this4.jobQueue.shift();

            return _this4.hasQueuedJobs ? yield _this4.currentJob.popNextTestRunUrl(_this4) : null;
        })();
    }

    static getById(id) {
        return connections[id] || null;
    }

    addWarning(...args) {
        if (this.currentJob) this.currentJob.warningLog.addWarning(...args);
    }

    setProviderMetaInfo(str) {
        this.browserInfo.userAgentProviderMetaInfo = str;
    }

    get userAgent() {
        var userAgent = this.browserInfo.userAgent;

        if (this.browserInfo.userAgentProviderMetaInfo) userAgent += ` (${this.browserInfo.userAgentProviderMetaInfo})`;

        return userAgent;
    }

    get hasQueuedJobs() {
        return !!this.jobQueue.length;
    }

    get currentJob() {
        return this.jobQueue[0];
    }

    // API
    runInitScript(code) {
        return new _pinkie2.default(resolve => this.initScriptsQueue.push({ code, resolve }));
    }

    addJob(job) {
        this.jobQueue.push(job);
    }

    removeJob(job) {
        (0, _lodash.pull)(this.jobQueue, job);
    }

    close() {
        if (this.closed || this.closing) return;

        this.closing = true;

        this._closeBrowser().then(() => {
            this.browserConnectionGateway.stopServingConnection(this);
            clearTimeout(this.heartbeatTimeout);

            delete connections[this.id];

            this.ready = false;
            this.closed = true;

            this.emit('closed');
        });
    }

    establish(userAgent) {
        this.ready = true;

        const parsedUserAgent = (0, _useragent.parse)(userAgent);

        this.browserInfo.userAgent = parsedUserAgent.toString();
        this.browserInfo.fullUserAgent = userAgent;
        this.browserInfo.parsedUserAgent = parsedUserAgent;

        this._waitForHeartbeat();
        this.emit('ready');
    }

    heartbeat() {
        clearTimeout(this.heartbeatTimeout);
        this._waitForHeartbeat();

        return {
            code: this.closing ? _status2.default.closing : _status2.default.ok,
            url: this.closing ? this.idleUrl : ''
        };
    }

    renderIdlePage() {
        return _mustache2.default.render(IDLE_PAGE_TEMPLATE, {
            userAgent: this.userAgent,
            statusUrl: this.statusUrl,
            heartbeatUrl: this.heartbeatUrl,
            initScriptUrl: this.initScriptUrl
        });
    }

    getInitScript() {
        var initScriptPromise = this.initScriptsQueue[0];

        return { code: initScriptPromise ? initScriptPromise.code : null };
    }

    handleInitScriptResult(data) {
        var initScriptPromise = this.initScriptsQueue.shift();

        if (initScriptPromise) initScriptPromise.resolve(JSON.parse(data));
    }

    reportJobResult(status, data) {
        var _this5 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            yield _this5.provider.reportJobResult(_this5.id, status, data);
        })();
    }

    getStatus(isTestDone) {
        var _this6 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (!_this6.idle && !isTestDone) {
                _this6.idle = true;
                _this6.emit('idle');
            }

            if (_this6.opened) {
                var testRunUrl = yield _this6._getTestRunUrl(isTestDone);

                if (testRunUrl) {
                    _this6.idle = false;
                    return { cmd: _command2.default.run, url: testRunUrl };
                }
            }

            return { cmd: _command2.default.idle, url: _this6.idleUrl };
        })();
    }
}
exports.default = BrowserConnection;
module.exports = exports['default'];
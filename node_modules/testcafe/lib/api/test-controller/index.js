'use strict';

exports.__esModule = true;

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _lodash = require('lodash');

var _getCallsite = require('../../errors/get-callsite');

var _clientFunctionBuilder = require('../../client-functions/client-function-builder');

var _clientFunctionBuilder2 = _interopRequireDefault(_clientFunctionBuilder);

var _assertion = require('./assertion');

var _assertion2 = _interopRequireDefault(_assertion);

var _delegatedApi = require('../../utils/delegated-api');

var _actions = require('../../test-run/commands/actions');

var _browserManipulation = require('../../test-run/commands/browser-manipulation');

var _observation = require('../../test-run/commands/observation');

var _assertType = require('../request-hooks/assert-type');

var _assertType2 = _interopRequireDefault(_assertType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TestController {
    constructor(testRun) {
        this.testRun = testRun;
        this.executionChain = _pinkie2.default.resolve();
        this.callsitesWithoutAwait = new _set2.default();
    }

    // NOTE: we track missing `awaits` by exposing a special custom Promise to user code.
    // Action or assertion is awaited if:
    // a)someone used `await` so Promise's `then` function executed
    // b)Promise chained by using one of the mixed-in controller methods
    //
    // In both scenarios, we check that callsite that produced Promise is equal to the one
    // that is currently missing await. This is required to workaround scenarios like this:
    //
    // var t2 = t.click('#btn1'); // <-- stores new callsiteWithoutAwait
    // await t2;                  // <-- callsiteWithoutAwait = null
    // t.click('#btn2');          // <-- stores new callsiteWithoutAwait
    // await t2.click('#btn3');   // <-- without check it will set callsiteWithoutAwait = null, so we will lost tracking
    _createExtendedPromise(promise, callsite) {
        var extendedPromise = promise.then(_lodash.identity);
        var originalThen = extendedPromise.then;
        var markCallsiteAwaited = () => this.callsitesWithoutAwait.delete(callsite);

        extendedPromise.then = function () {
            markCallsiteAwaited();
            return originalThen.apply(this, arguments);
        };

        (0, _delegatedApi.delegateAPI)(extendedPromise, TestController.API_LIST, {
            handler: this,
            proxyMethod: markCallsiteAwaited
        });

        return extendedPromise;
    }

    _enqueueTask(apiMethodName, createTaskExecutor) {
        var callsite = (0, _getCallsite.getCallsiteForMethod)(apiMethodName);
        var executor = createTaskExecutor(callsite);

        this.executionChain = this.executionChain.then(executor);

        this.callsitesWithoutAwait.add(callsite);

        return this._createExtendedPromise(this.executionChain, callsite);
    }

    _enqueueCommand(apiMethodName, CmdCtor, cmdArgs) {
        return this._enqueueTask(apiMethodName, callsite => {
            var command = null;

            try {
                command = new CmdCtor(cmdArgs, this.testRun);
            } catch (err) {
                err.callsite = callsite;
                throw err;
            }

            return () => this.testRun.executeCommand(command, callsite);
        });
    }

    // API implementation
    // We need implementation methods to obtain correct callsites. If we use plain API
    // methods in chained wrappers then we will have callsite for the wrapped method
    // in this file instead of chained method callsite in user code.
    _ctx$getter() {
        return this.testRun.ctx;
    }

    _ctx$setter(val) {
        this.testRun.ctx = val;

        return this.testRun.ctx;
    }

    _fixtureCtx$getter() {
        return this.testRun.fixtureCtx;
    }

    _click$(selector, options) {
        return this._enqueueCommand('click', _actions.ClickCommand, { selector, options });
    }

    _rightClick$(selector, options) {
        return this._enqueueCommand('rightClick', _actions.RightClickCommand, { selector, options });
    }

    _doubleClick$(selector, options) {
        return this._enqueueCommand('doubleClick', _actions.DoubleClickCommand, { selector, options });
    }

    _hover$(selector, options) {
        return this._enqueueCommand('hover', _actions.HoverCommand, { selector, options });
    }

    _drag$(selector, dragOffsetX, dragOffsetY, options) {
        return this._enqueueCommand('drag', _actions.DragCommand, { selector, dragOffsetX, dragOffsetY, options });
    }

    _dragToElement$(selector, destinationSelector, options) {
        return this._enqueueCommand('dragToElement', _actions.DragToElementCommand, { selector, destinationSelector, options });
    }

    _typeText$(selector, text, options) {
        return this._enqueueCommand('typeText', _actions.TypeTextCommand, { selector, text, options });
    }

    _selectText$(selector, startPos, endPos, options) {
        return this._enqueueCommand('selectText', _actions.SelectTextCommand, { selector, startPos, endPos, options });
    }

    _selectTextAreaContent$(selector, startLine, startPos, endLine, endPos, options) {
        return this._enqueueCommand('selectTextAreaContent', _actions.SelectTextAreaContentCommand, {
            selector,
            startLine,
            startPos,
            endLine,
            endPos,
            options
        });
    }

    _selectEditableContent$(startSelector, endSelector, options) {
        return this._enqueueCommand('selectEditableContent', _actions.SelectEditableContentCommand, {
            startSelector,
            endSelector,
            options
        });
    }

    _pressKey$(keys, options) {
        return this._enqueueCommand('pressKey', _actions.PressKeyCommand, { keys, options });
    }

    _wait$(timeout) {
        return this._enqueueCommand('wait', _observation.WaitCommand, { timeout });
    }

    _navigateTo$(url) {
        return this._enqueueCommand('navigateTo', _actions.NavigateToCommand, { url });
    }

    _setFilesToUpload$(selector, filePath) {
        return this._enqueueCommand('setFilesToUpload', _actions.SetFilesToUploadCommand, { selector, filePath });
    }

    _clearUpload$(selector) {
        return this._enqueueCommand('clearUpload', _actions.ClearUploadCommand, { selector });
    }

    _takeScreenshot$(path) {
        return this._enqueueCommand('takeScreenshot', _browserManipulation.TakeScreenshotCommand, { path });
    }

    _takeElementScreenshot$(selector, ...args) {
        var commandArgs = { selector };

        if (args[1]) {
            commandArgs.path = args[0];
            commandArgs.options = args[1];
        } else if (typeof args[0] === 'object') commandArgs.options = args[0];else commandArgs.path = args[0];

        return this._enqueueCommand('takeElementScreenshot', _browserManipulation.TakeElementScreenshotCommand, commandArgs);
    }

    _resizeWindow$(width, height) {
        return this._enqueueCommand('resizeWindow', _browserManipulation.ResizeWindowCommand, { width, height });
    }

    _resizeWindowToFitDevice$(device, options) {
        return this._enqueueCommand('resizeWindowToFitDevice', _browserManipulation.ResizeWindowToFitDeviceCommand, { device, options });
    }

    _maximizeWindow$() {
        return this._enqueueCommand('maximizeWindow', _browserManipulation.MaximizeWindowCommand);
    }

    _switchToIframe$(selector) {
        return this._enqueueCommand('switchToIframe', _actions.SwitchToIframeCommand, { selector });
    }

    _switchToMainWindow$() {
        return this._enqueueCommand('switchToMainWindow', _actions.SwitchToMainWindowCommand);
    }

    _eval$(fn, options) {
        if (!(0, _lodash.isNil)(options)) options = (0, _lodash.assign)({}, options, { boundTestRun: this });

        var builder = new _clientFunctionBuilder2.default(fn, options, { instantiation: 'eval', execution: 'eval' });
        var clientFn = builder.getFunction();

        return clientFn();
    }

    _setNativeDialogHandler$(fn, options) {
        return this._enqueueCommand('setNativeDialogHandler', _actions.SetNativeDialogHandlerCommand, {
            dialogHandler: { fn, options }
        });
    }

    _getNativeDialogHistory$() {
        var callsite = (0, _getCallsite.getCallsiteForMethod)('getNativeDialogHistory');

        return this.testRun.executeCommand(new _actions.GetNativeDialogHistoryCommand(), callsite);
    }

    _getBrowserConsoleMessages$() {
        var callsite = (0, _getCallsite.getCallsiteForMethod)('getBrowserConsoleMessages');

        return this.testRun.executeCommand(new _actions.GetBrowserConsoleMessagesCommand(), callsite);
    }

    _expect$(actual) {
        return new _assertion2.default(actual, this);
    }

    _debug$() {
        return this._enqueueCommand('debug', _observation.DebugCommand);
    }

    _setTestSpeed$(speed) {
        return this._enqueueCommand('setTestSpeed', _actions.SetTestSpeedCommand, { speed });
    }

    _setPageLoadTimeout$(duration) {
        return this._enqueueCommand('setPageLoadTimeout', _actions.SetPageLoadTimeoutCommand, { duration });
    }

    _useRole$(role) {
        return this._enqueueCommand('useRole', _actions.UseRoleCommand, { role });
    }

    _addRequestHooks$(...hooks) {
        return this._enqueueTask('addRequestHooks', () => {
            hooks = (0, _lodash.flattenDeep)(hooks);

            (0, _assertType2.default)(hooks);

            hooks.forEach(hook => this.testRun.addRequestHook(hook));
        });
    }

    _removeRequestHooks$(...hooks) {
        return this._enqueueTask('removeRequestHooks', () => {
            hooks = (0, _lodash.flattenDeep)(hooks);

            (0, _assertType2.default)(hooks);

            hooks.forEach(hook => this.testRun.removeRequestHook(hook));
        });
    }
}

exports.default = TestController;
TestController.API_LIST = (0, _delegatedApi.getDelegatedAPIList)(TestController.prototype);

(0, _delegatedApi.delegateAPI)(TestController.prototype, TestController.API_LIST, { useCurrentCtxAsHandler: true });
module.exports = exports['default'];
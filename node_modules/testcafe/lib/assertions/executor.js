'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _events = require('events');

var _delay = require('../utils/delay');

var _delay2 = _interopRequireDefault(_delay);

var _thennable = require('../utils/thennable');

var _testRun = require('../errors/test-run');

var _reExecutablePromise = require('../utils/re-executable-promise');

var _reExecutablePromise2 = _interopRequireDefault(_reExecutablePromise);

var _getFn = require('./get-fn');

var _getFn2 = _interopRequireDefault(_getFn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ASSERTION_DELAY = 200;

class AssertionExecutor extends _events.EventEmitter {
    constructor(command, timeout, callsite) {
        super();

        this.command = command;
        this.timeout = timeout;
        this.callsite = callsite;

        this.startTime = null;
        this.passed = false;
        this.inRetry = false;

        var fn = (0, _getFn2.default)(this.command);
        var actualCommand = this.command.actual;

        if (actualCommand instanceof _reExecutablePromise2.default) this.fn = this._wrapFunction(fn);else if (!this.command.options.allowUnawaitedPromise && (0, _thennable.isThennable)(actualCommand)) throw new _testRun.AssertionUnawaitedPromiseError(this.callsite);else this.fn = fn;
    }

    _getTimeLeft() {
        return this.timeout - (new Date() - this.startTime);
    }

    _onExecutionFinished() {
        if (this.inRetry) this.emit('end-assertion-retries', this.passed);
    }

    _wrapFunction(fn) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var resultPromise = _this.command.actual;

            while (!_this.passed) {
                _this.command.actual = yield resultPromise._reExecute();

                try {
                    fn();
                    _this.passed = true;
                    _this._onExecutionFinished();
                } catch (err) {
                    if (_this._getTimeLeft() <= 0) {
                        _this._onExecutionFinished();
                        throw err;
                    }

                    yield (0, _delay2.default)(ASSERTION_DELAY);

                    _this.inRetry = true;
                    _this.emit('start-assertion-retries', _this._getTimeLeft());
                }
            }
        });
    }

    run() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            _this2.startTime = new Date();

            try {
                yield _this2.fn();
            } catch (err) {
                if (err.name === 'AssertionError' || err.constructor.name === 'AssertionError') throw new _testRun.ExternalAssertionLibraryError(err, _this2.callsite);

                if (err.isTestCafeError) err.callsite = _this2.callsite;

                throw err;
            }
        })();
    }
}
exports.default = AssertionExecutor;
module.exports = exports['default'];
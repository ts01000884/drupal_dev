'use strict';

exports.__esModule = true;
exports.ClientFunctionAPIError = exports.APIError = exports.TestCompilationError = exports.GeneralError = undefined;

var _callsiteRecord = require('callsite-record');

var _message = require('./message');

var _message2 = _interopRequireDefault(_message);

var _createStackFilter = require('../create-stack-filter');

var _createStackFilter2 = _interopRequireDefault(_createStackFilter);

var _getCallsite = require('../get-callsite');

var _renderTemplate = require('../../utils/render-template');

var _renderTemplate2 = _interopRequireDefault(_renderTemplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Errors
class GeneralError extends Error {
    constructor() {
        super(_renderTemplate2.default.apply(null, arguments));
        Error.captureStackTrace(this, GeneralError);

        // HACK: workaround for the `instanceof` problem
        // (see: http://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node)
        this.constructor = GeneralError;
    }
}

exports.GeneralError = GeneralError;
class TestCompilationError extends Error {
    constructor(originalError) {
        super((0, _renderTemplate2.default)(_message2.default.cannotPrepareTestsDueToError, originalError.toString()));

        // NOTE: stack includes message as well.
        this.stack = (0, _renderTemplate2.default)(_message2.default.cannotPrepareTestsDueToError, originalError.stack);
        this.constructor = TestCompilationError;
    }
}

exports.TestCompilationError = TestCompilationError;
class APIError extends Error {
    constructor(methodName, template, ...args) {
        var rawMessage = (0, _renderTemplate2.default)(template, ...args);

        super((0, _renderTemplate2.default)(_message2.default.cannotPrepareTestsDueToError, rawMessage));

        // NOTE: `rawMessage` is used in error substitution if it occurs in test run.
        this.rawMessage = rawMessage;
        this.callsite = (0, _getCallsite.getCallsiteForMethod)(methodName);
        this.constructor = APIError;

        // HACK: prototype properties don't work with built-in subclasses
        // (see: http://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node)
        Object.defineProperty(this, 'stack', {
            get: () => APIError._createStack(this.message, this.callsite, _callsiteRecord.renderers.noColor)
        });

        Object.defineProperty(this, 'coloredStack', {
            get: () => APIError._createStack(this.message, this.callsite, _callsiteRecord.renderers.default)
        });
    }

    static _createStack(message, callsiteRecord, renderer) {
        return message + '\n\n' + callsiteRecord.renderSync({
            renderer: renderer,
            stackFilter: (0, _createStackFilter2.default)(Error.stackTraceLimit)
        });
    }
}

exports.APIError = APIError;
class ClientFunctionAPIError extends APIError {
    constructor(methodName, instantiationCallsiteName, template, ...args) {
        template = template.replace(/\{#instantiationCallsiteName\}/g, instantiationCallsiteName);

        super(methodName, template, ...args);
    }
}
exports.ClientFunctionAPIError = ClientFunctionAPIError;
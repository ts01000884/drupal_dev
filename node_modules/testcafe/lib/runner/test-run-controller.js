'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _testcafeLegacyApi = require('testcafe-legacy-api');

var _testRun = require('../test-run');

var _testRun2 = _interopRequireDefault(_testRun);

var _sessionController = require('../test-run/session-controller');

var _sessionController2 = _interopRequireDefault(_sessionController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Const
const QUARANTINE_THRESHOLD = 3;

class Quarantine {
    constructor() {
        this.attempts = [];
    }

    getFailedAttempts() {
        return this.attempts.filter(errors => !!errors.length);
    }

    getPassedAttempts() {
        return this.attempts.filter(errors => errors.length === 0);
    }

    getNextAttemptNumber() {
        return this.attempts.length + 1;
    }
}

class TestRunController extends _events2.default {
    constructor(test, index, proxy, screenshots, warningLog, fixtureHookController, opts) {
        super();

        this.test = test;
        this.index = index;
        this.opts = opts;

        this.proxy = proxy;
        this.screenshots = screenshots;
        this.warningLog = warningLog;
        this.fixtureHookController = fixtureHookController;

        this.TestRunCtor = TestRunController._getTestRunCtor(test, opts);

        this.testRun = null;
        this.done = false;
        this.quarantine = null;

        if (this.opts.quarantineMode) this.quarantine = new Quarantine();
    }

    static _getTestRunCtor(test, opts) {
        if (opts.TestRunCtor) return opts.TestRunCtor;

        return test.isLegacy ? _testcafeLegacyApi.TestRun : _testRun2.default;
    }

    _createTestRun(connection) {
        var screenshotCapturer = this.screenshots.createCapturerFor(this.test, this.index, this.quarantine, connection, this.warningLog);
        var TestRunCtor = this.TestRunCtor;

        this.testRun = new TestRunCtor(this.test, connection, screenshotCapturer, this.warningLog, this.opts);

        if (this.testRun.addQuarantineInfo) this.testRun.addQuarantineInfo(this.quarantine);

        return this.testRun;
    }

    _endQuarantine() {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (_this.quarantine.attempts.length > 1) _this.testRun.unstable = _this.quarantine.getPassedAttempts().length > 0;

            yield _this._emitTestRunDone();
        })();
    }

    _shouldKeepInQuarantine() {
        const errors = this.testRun.errs;
        const attempts = this.quarantine.attempts;

        attempts.push(errors);

        const failedTimes = this.quarantine.getFailedAttempts().length;
        const passedTimes = this.quarantine.getPassedAttempts().length;
        const hasErrors = !!errors.length;
        const isFirstAttempt = attempts.length === 1;
        const failedThresholdReached = failedTimes >= QUARANTINE_THRESHOLD;
        const passedThresholdReached = passedTimes >= QUARANTINE_THRESHOLD;

        return isFirstAttempt ? hasErrors : !failedThresholdReached && !passedThresholdReached;
    }

    _keepInQuarantine() {
        this.emit('test-run-restart');
    }

    _testRunDoneInQuarantineMode() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (_this2._shouldKeepInQuarantine()) _this2._keepInQuarantine();else yield _this2._endQuarantine();
        })();
    }

    _testRunDone() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (_this3.quarantine) yield _this3._testRunDoneInQuarantineMode();else yield _this3._emitTestRunDone();
        })();
    }

    _emitTestRunDone() {
        var _this4 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // NOTE: we should report test run completion in order they were completed in browser.
            // To keep a sequence after fixture hook execution we use completion queue.
            yield _this4.fixtureHookController.runFixtureAfterHookIfNecessary(_this4.testRun);

            _this4.done = true;

            _this4.emit('test-run-done');
        })();
    }

    get blocked() {
        return this.fixtureHookController.isTestBlocked(this.test);
    }

    start(connection) {
        var _this5 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var testRun = _this5._createTestRun(connection);

            var hookOk = yield _this5.fixtureHookController.runFixtureBeforeHookIfNecessary(testRun);

            if (_this5.test.skip || !hookOk) {
                _this5.emit('test-run-start');
                yield _this5._emitTestRunDone();
                return null;
            }

            testRun.once('start', function () {
                return _this5.emit('test-run-start');
            });
            testRun.once('done', function () {
                return _this5._testRunDone();
            });

            testRun.start();

            return _sessionController2.default.getSessionUrl(testRun, _this5.proxy);
        })();
    }
}
exports.default = TestRunController;
module.exports = exports['default'];
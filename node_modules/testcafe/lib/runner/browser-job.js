'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _events = require('events');

var _lodash = require('lodash');

var _testRunController = require('./test-run-controller');

var _testRunController2 = _interopRequireDefault(_testRunController);

var _sessionController = require('../test-run/session-controller');

var _sessionController2 = _interopRequireDefault(_sessionController);

var _browserJobResult = require('./browser-job-result');

var _browserJobResult2 = _interopRequireDefault(_browserJobResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Browser job
class BrowserJob extends _events.EventEmitter {
    constructor(tests, browserConnections, proxy, screenshots, warningLog, fixtureHookController, opts) {
        super();

        this.started = false;

        this.total = 0;
        this.passed = 0;
        this.opts = opts;
        this.proxy = proxy;
        this.browserConnections = browserConnections;
        this.screenshots = screenshots;
        this.warningLog = warningLog;
        this.fixtureHookController = fixtureHookController;
        this.result = null;

        this.testRunControllerQueue = tests.map((test, index) => this._createTestRunController(test, index));

        this.completionQueue = [];

        this.connectionErrorListener = error => this._setResult(_browserJobResult2.default.errored, error);

        this.browserConnections.map(bc => bc.once('error', this.connectionErrorListener));
    }

    _createTestRunController(test, index) {
        var testRunController = new _testRunController2.default(test, index + 1, this.proxy, this.screenshots, this.warningLog, this.fixtureHookController, this.opts);

        testRunController.on('test-run-start', () => this.emit('test-run-start', testRunController.testRun));
        testRunController.on('test-run-restart', () => this._onTestRunRestart(testRunController));
        testRunController.on('test-run-done', () => this._onTestRunDone(testRunController));

        return testRunController;
    }

    _setResult(status, data) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (_this.result) return;

            _this.result = { status, data };

            _this.browserConnections.forEach(function (bc) {
                return bc.removeListener('error', _this.connectionErrorListener);
            });

            yield _pinkie2.default.all(_this.browserConnections.map(function (bc) {
                return bc.reportJobResult(_this.result.status, _this.result.data);
            }));
        })();
    }

    _addToCompletionQueue(testRunInfo) {
        this.completionQueue.push(testRunInfo);
    }

    _removeFromCompletionQueue(testRunInfo) {
        (0, _lodash.remove)(this.completionQueue, testRunInfo);
    }

    _onTestRunRestart(testRunController) {
        this._removeFromCompletionQueue(testRunController);
        this.testRunControllerQueue.unshift(testRunController);
    }

    _onTestRunDone(testRunController) {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            _this2.total++;

            if (!testRunController.testRun.errs.length) _this2.passed++;

            while (_this2.completionQueue.length && _this2.completionQueue[0].done) {
                testRunController = _this2.completionQueue.shift();

                _this2.emit('test-run-done', testRunController.testRun);
            }

            if (!_this2.completionQueue.length && !_this2.hasQueuedTestRuns) {
                _sessionController2.default.closeSession(testRunController.testRun);

                _this2._setResult(_browserJobResult2.default.done, { total: _this2.total, passed: _this2.passed }).then(function () {
                    return _this2.emit('done');
                });
            }
        })();
    }

    // API
    get hasQueuedTestRuns() {
        return !!this.testRunControllerQueue.length;
    }

    popNextTestRunUrl(connection) {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            while (_this3.testRunControllerQueue.length) {
                // NOTE: before hook for test run fixture is currently
                // executing, so test run is temporary blocked
                if (_this3.testRunControllerQueue[0].blocked) break;

                var testRunController = _this3.testRunControllerQueue.shift();

                _this3._addToCompletionQueue(testRunController);

                if (!_this3.started) {
                    _this3.started = true;
                    _this3.emit('start');
                }

                var testRunUrl = yield testRunController.start(connection);

                if (testRunUrl) return testRunUrl;
            }

            return null;
        })();
    }

    abort() {
        this.removeAllListeners();
        this._setResult(_browserJobResult2.default.aborted);
        this.browserConnections.map(bc => bc.removeJob(this));
    }
}
exports.default = BrowserJob;
module.exports = exports['default'];
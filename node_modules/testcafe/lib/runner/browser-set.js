'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _events = require('events');

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _timeLimitPromise = require('time-limit-promise');

var _timeLimitPromise2 = _interopRequireDefault(_timeLimitPromise);

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _lodash = require('lodash');

var _mapReverse = require('map-reverse');

var _mapReverse2 = _interopRequireDefault(_mapReverse);

var _runtime = require('../errors/runtime');

var _message = require('../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LOCAL_BROWSERS_READY_TIMEOUT = 2 * 60 * 1000;
const REMOTE_BROWSERS_READY_TIMEOUT = 6 * 60 * 1000;

class BrowserSet extends _events.EventEmitter {
    constructor(browserConnectionGroups) {
        super();

        this.RELEASE_TIMEOUT = 10000;

        this.pendingReleases = [];

        this.browserConnectionGroups = browserConnectionGroups;
        this.browserConnections = (0, _lodash.flatten)(browserConnectionGroups);

        this.connectionsReadyTimeout = null;

        this.browserErrorHandler = error => this.emit('error', error);

        this.browserConnections.forEach(bc => bc.on('error', this.browserErrorHandler));

        // NOTE: We're setting an empty error handler, because Node kills the process on an 'error' event
        // if there is no handler. See: https://nodejs.org/api/events.html#events_class_events_eventemitter
        this.on('error', _lodash.noop);
    }

    static _waitIdle(bc) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (bc.idle || !bc.ready) return;

            yield (0, _promisifyEvent2.default)(bc, 'idle');
        })();
    }

    static _closeConnection(bc) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (bc.closed || !bc.ready) return;

            bc.close();

            yield (0, _promisifyEvent2.default)(bc, 'closed');
        })();
    }

    _getReadyTimeout() {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var isLocalBrowser = function isLocalBrowser(connection) {
                return connection.provider.isLocalBrowser(connection.id, connection.browserInfo.browserName);
            };
            var remoteBrowsersExist = (yield _pinkie2.default.all(_this.browserConnections.map(isLocalBrowser))).indexOf(false) > -1;

            return remoteBrowsersExist ? REMOTE_BROWSERS_READY_TIMEOUT : LOCAL_BROWSERS_READY_TIMEOUT;
        })();
    }

    _createPendingConnectionPromise(readyPromise, timeout, timeoutError) {
        const timeoutPromise = new _pinkie2.default((_, reject) => {
            this.connectionsReadyTimeout = setTimeout(() => reject(timeoutError), timeout);
        });

        return _pinkie2.default.race([readyPromise, timeoutPromise]).then(value => {
            this.connectionsReadyTimeout.unref();
            return value;
        }, error => {
            this.connectionsReadyTimeout.unref();
            throw error;
        });
    }

    _waitConnectionsOpened() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var connectionsReadyPromise = _pinkie2.default.all(_this2.browserConnections.filter(function (bc) {
                return !bc.opened;
            }).map(function (bc) {
                return (0, _promisifyEvent2.default)(bc, 'opened');
            }));

            var timeoutError = new _runtime.GeneralError(_message2.default.cantEstablishBrowserConnection);
            var readyTimeout = yield _this2._getReadyTimeout();

            yield _this2._createPendingConnectionPromise(connectionsReadyPromise, readyTimeout, timeoutError);
        })();
    }

    _checkForDisconnections() {
        var disconnectedUserAgents = this.browserConnections.filter(bc => bc.closed).map(bc => bc.userAgent);

        if (disconnectedUserAgents.length) throw new _runtime.GeneralError(_message2.default.cantRunAgainstDisconnectedBrowsers, disconnectedUserAgents.join(', '));
    }

    //API
    static from(browserConnections) {
        var browserSet = new BrowserSet(browserConnections);

        var prepareConnection = _pinkie2.default.resolve().then(() => {
            browserSet._checkForDisconnections();
            return browserSet._waitConnectionsOpened();
        }).then(() => browserSet);

        return _pinkie2.default.race([prepareConnection, (0, _promisifyEvent2.default)(browserSet, 'error')]).catch((() => {
            var _ref = (0, _asyncToGenerator3.default)(function* (error) {
                yield browserSet.dispose();

                throw error;
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());
    }

    releaseConnection(bc) {
        if (this.browserConnections.indexOf(bc) < 0) return _pinkie2.default.resolve();

        (0, _lodash.pull)(this.browserConnections, bc);

        bc.removeListener('error', this.browserErrorHandler);

        var appropriateStateSwitch = !bc.permanent ? BrowserSet._closeConnection(bc) : BrowserSet._waitIdle(bc);

        var release = (0, _timeLimitPromise2.default)(appropriateStateSwitch, this.RELEASE_TIMEOUT).then(() => (0, _lodash.pull)(this.pendingReleases, release));

        this.pendingReleases.push(release);

        return release;
    }

    dispose() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // NOTE: When browserConnection is cancelled, it is removed from
            // the this.connections array, which leads to shifting indexes
            // towards the beginning. So, we must copy the array in order to iterate it,
            // or we can perform iteration from the end to the beginning.
            if (_this3.connectionsReadyTimeout) _this3.connectionsReadyTimeout.unref();

            (0, _mapReverse2.default)(_this3.browserConnections, function (bc) {
                return _this3.releaseConnection(bc);
            });

            yield _pinkie2.default.all(_this3.pendingReleases);
        })();
    }
}
exports.default = BrowserSet;
module.exports = exports['default'];
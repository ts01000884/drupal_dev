'use strict';

exports.__esModule = true;

var _errorStackParser = require('error-stack-parser');

var _errorStackParser2 = _interopRequireDefault(_errorStackParser);

var _createStackFilter = require('./create-stack-filter');

var _createStackFilter2 = _interopRequireDefault(_createStackFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ORIGINAL_STACK_TRACE_LIMIT = Error.stackTraceLimit;
const STACK_TRACE_LIMIT = 200;
const TOP_ANONYMOUS_FRAME_RE = /\s+at\s<anonymous>$/;
const GENERATOR_NEXT_FRAME_RE = /\s+at\sgenerator.next\s\(<anonymous>\)$/im;

exports.default = {
    isEnabled: false,

    _getFrames(error) {
        try {
            return _errorStackParser2.default.parse(error);
        } catch (e) {
            return [];
        }
    },

    _renderFrameInfo(frames) {
        return frames.map(frame => frame.getSource()).join('\n');
    },

    get enabled() {
        return this.isEnabled;
    },

    set enabled(val) {
        if (this.isEnabled === val) return;

        this.isEnabled = val;

        // NOTE: Babel errors may have really deep stacks,
        // so we increase stack trace capacity
        if (this.isEnabled) Error.stackTraceLimit = STACK_TRACE_LIMIT;else Error.stackTraceLimit = ORIGINAL_STACK_TRACE_LIMIT;
    },

    cleanError(error) {
        error.stack = error.stack.replace(TOP_ANONYMOUS_FRAME_RE, '');
        error.stack = error.stack.replace(GENERATOR_NEXT_FRAME_RE, '');

        let frames = this._getFrames(error);

        if (!frames.length) return error;

        error.stack = error.stack.replace(this._renderFrameInfo(frames), '');

        frames = frames.filter((0, _createStackFilter2.default)(ORIGINAL_STACK_TRACE_LIMIT));

        error.stack += this._renderFrameInfo(frames);

        return error;
    }
};
module.exports = exports['default'];
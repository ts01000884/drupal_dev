'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _pngjs = require('pngjs');

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _limitNumber = require('../utils/limit-number');

var _limitNumber2 = _interopRequireDefault(_limitNumber);

var _promisifiedFunctions = require('../utils/promisified-functions');

var _renderTemplate = require('../utils/render-template');

var _renderTemplate2 = _interopRequireDefault(_renderTemplate);

var _testRun = require('../errors/test-run/');

var _constants = require('./constants');

var _warningMessage = require('../notifications/warning-message');

var _warningMessage2 = _interopRequireDefault(_warningMessage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readPng(filePath) {
    var png = new _pngjs.PNG();
    var parsedPromise = _pinkie2.default.race([(0, _promisifyEvent2.default)(png, 'parsed'), (0, _promisifyEvent2.default)(png, 'error')]);

    _fs2.default.createReadStream(filePath).pipe(png);

    return parsedPromise.then(() => png);
}

function writePng(filePath, png) {
    var outStream = _fs2.default.createWriteStream(filePath);
    var finishPromise = _pinkie2.default.race([(0, _promisifyEvent2.default)(outStream, 'finish'), (0, _promisifyEvent2.default)(outStream, 'error')]);

    png.pack().pipe(outStream);

    return finishPromise;
}

function markSeedToId(markSeed) {
    let id = 0;

    for (let i = 0; i < _constants.MARK_LENGTH; i++) id = id * 2 + (markSeed[i * _constants.MARK_BYTES_PER_PIXEL] ? 1 : 0);

    return id;
}

function detectClippingArea(srcImage, { markSeed, clientAreaDimensions, cropDimensions, screenshotPath } = {}) {
    let clipLeft = 0;
    let clipTop = 0;
    let clipRight = srcImage.width;
    let clipBottom = srcImage.height;
    let clipWidth = srcImage.width;
    let clipHeight = srcImage.height;

    if (markSeed && clientAreaDimensions) {
        var mark = Buffer.from(markSeed);

        var markIndex = srcImage.data.indexOf(mark);

        if (markIndex < 0) throw new Error((0, _renderTemplate2.default)(_warningMessage2.default.screenshotMarkNotFound, screenshotPath, markSeedToId(markSeed)));

        var endPosition = markIndex / _constants.MARK_BYTES_PER_PIXEL + _constants.MARK_LENGTH + _constants.MARK_RIGHT_MARGIN;

        clipRight = endPosition % srcImage.width || srcImage.width;
        clipBottom = (endPosition - clipRight) / srcImage.width + 1;
        clipLeft = clipRight - clientAreaDimensions.width;
        clipTop = clipBottom - clientAreaDimensions.height;
    }

    const markLineNumber = clipBottom;

    if (cropDimensions) {
        clipRight = (0, _limitNumber2.default)(clipLeft + cropDimensions.right, clipLeft, clipRight);
        clipBottom = (0, _limitNumber2.default)(clipTop + cropDimensions.bottom, clipTop, clipBottom);
        clipLeft = (0, _limitNumber2.default)(clipLeft + cropDimensions.left, clipLeft, clipRight);
        clipTop = (0, _limitNumber2.default)(clipTop + cropDimensions.top, clipTop, clipBottom);
    }

    if (markSeed && clipBottom === markLineNumber) clipBottom -= 1;

    clipWidth = clipRight - clipLeft;
    clipHeight = clipBottom - clipTop;

    return {
        left: clipLeft,
        top: clipTop,
        right: clipRight,
        bottom: clipBottom,
        width: clipWidth,
        height: clipHeight
    };
}

function copyImagePart(srcImage, { left, top, width, height }) {
    var dstImage = new _pngjs.PNG({ width, height });
    var stride = dstImage.width * _constants.MARK_BYTES_PER_PIXEL;

    for (let i = 0; i < height; i++) {
        var srcStartIndex = (srcImage.width * (i + top) + left) * _constants.MARK_BYTES_PER_PIXEL;

        srcImage.data.copy(dstImage.data, stride * i, srcStartIndex, srcStartIndex + stride);
    }

    return dstImage;
}

exports.default = (() => {
    var _ref = (0, _asyncToGenerator3.default)(function* (screenshotPath, markSeed, clientAreaDimensions, cropDimensions) {
        var srcImage = yield readPng(screenshotPath);

        const clippingArea = detectClippingArea(srcImage, { markSeed, clientAreaDimensions, cropDimensions, screenshotPath });

        if (clippingArea.width <= 0 || clippingArea.height <= 0) {
            yield (0, _promisifiedFunctions.deleteFile)(screenshotPath);
            throw new _testRun.InvalidElementScreenshotDimensionsError(clippingArea.width, clippingArea.height);
        }

        if (!markSeed && !cropDimensions) return true;

        const dstImage = copyImagePart(srcImage, clippingArea);

        yield writePng(screenshotPath, dstImage);

        return true;
    });

    return function (_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
    };
})();

module.exports = exports['default'];
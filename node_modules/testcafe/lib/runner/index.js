'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _mapReverse = require('map-reverse');

var _mapReverse2 = _interopRequireDefault(_mapReverse);

var _events = require('events');

var _lodash = require('lodash');

var _bootstrapper = require('./bootstrapper');

var _bootstrapper2 = _interopRequireDefault(_bootstrapper);

var _reporter = require('../reporter');

var _reporter2 = _interopRequireDefault(_reporter);

var _task = require('./task');

var _task2 = _interopRequireDefault(_task);

var _runtime = require('../errors/runtime');

var _message = require('../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

var _typeAssertions = require('../errors/runtime/type-assertions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SELECTOR_TIMEOUT = 10000;
const DEFAULT_ASSERTION_TIMEOUT = 3000;
const DEFAULT_PAGE_LOAD_TIMEOUT = 3000;

class Runner extends _events.EventEmitter {
    constructor(proxy, browserConnectionGateway) {
        super();

        this.proxy = proxy;
        this.bootstrapper = new _bootstrapper2.default(browserConnectionGateway);
        this.pendingTaskPromises = [];

        this.opts = {
            externalProxyHost: null,
            proxyBypass: null,
            screenshotPath: null,
            takeScreenshotsOnFails: false,
            screenshotPathPattern: null,
            skipJsErrors: false,
            quarantineMode: false,
            debugMode: false,
            selectorTimeout: DEFAULT_SELECTOR_TIMEOUT,
            pageLoadTimeout: DEFAULT_PAGE_LOAD_TIMEOUT
        };
    }

    static _disposeTaskAndRelatedAssets(task, browserSet, testedApp) {
        return (0, _asyncToGenerator3.default)(function* () {
            task.abort();
            task.removeAllListeners();

            yield Runner._disposeBrowserSetAndTestedApp(browserSet, testedApp);
        })();
    }

    static _disposeBrowserSetAndTestedApp(browserSet, testedApp) {
        return (0, _asyncToGenerator3.default)(function* () {
            yield browserSet.dispose();

            if (testedApp) yield testedApp.kill();
        })();
    }

    _createCancelablePromise(taskPromise) {
        var promise = taskPromise.then(({ completionPromise }) => completionPromise);
        var removeFromPending = () => (0, _lodash.pull)(this.pendingTaskPromises, promise);

        promise.then(removeFromPending).catch(removeFromPending);

        promise.cancel = () => taskPromise.then(({ cancelTask }) => cancelTask()).then(removeFromPending);

        this.pendingTaskPromises.push(promise);
        return promise;
    }

    // Run task
    _getTaskResult(task, browserSet, reporter, testedApp) {
        return (0, _asyncToGenerator3.default)(function* () {
            task.on('browser-job-done', function (job) {
                return browserSet.releaseConnection(job.browserConnection);
            });

            var promises = [(0, _promisifyEvent2.default)(task, 'done'), (0, _promisifyEvent2.default)(browserSet, 'error')];

            if (testedApp) promises.push(testedApp.errorPromise);

            try {
                yield _pinkie2.default.race(promises);
            } catch (err) {
                yield Runner._disposeTaskAndRelatedAssets(task, browserSet, testedApp);

                throw err;
            }

            yield Runner._disposeBrowserSetAndTestedApp(browserSet, testedApp);

            return reporter.testCount - reporter.passed;
        })();
    }

    _runTask(reporterPlugins, browserSet, tests, testedApp) {
        var completed = false;
        var task = new _task2.default(tests, browserSet.browserConnectionGroups, this.proxy, this.opts);
        var reporters = reporterPlugins.map(reporter => new _reporter2.default(reporter.plugin, task, reporter.outStream));
        var completionPromise = this._getTaskResult(task, browserSet, reporters[0], testedApp);

        var setCompleted = () => {
            completed = true;
        };

        completionPromise.then(setCompleted).catch(setCompleted);

        var cancelTask = (() => {
            var _ref = (0, _asyncToGenerator3.default)(function* () {
                if (!completed) yield Runner._disposeTaskAndRelatedAssets(task, browserSet, testedApp);
            });

            return function cancelTask() {
                return _ref.apply(this, arguments);
            };
        })();

        return { completionPromise, cancelTask };
    }

    _registerAssets(assets) {
        assets.forEach(asset => this.proxy.GET(asset.path, asset.info));
    }

    _validateRunOptions() {
        const concurrency = this.bootstrapper.concurrency;
        const speed = this.opts.speed;
        let proxyBypass = this.opts.proxyBypass;

        if (typeof speed !== 'number' || isNaN(speed) || speed < 0.01 || speed > 1) throw new _runtime.GeneralError(_message2.default.invalidSpeedValue);

        if (typeof concurrency !== 'number' || isNaN(concurrency) || concurrency < 1) throw new _runtime.GeneralError(_message2.default.invalidConcurrencyFactor);

        if (proxyBypass) {
            (0, _typeAssertions.assertType)([_typeAssertions.is.string, _typeAssertions.is.array], null, '"proxyBypass" argument', proxyBypass);

            if (typeof proxyBypass === 'string') proxyBypass = [proxyBypass];

            proxyBypass = proxyBypass.reduce((arr, rules) => {
                (0, _typeAssertions.assertType)(_typeAssertions.is.string, null, '"proxyBypass" argument', rules);

                return arr.concat(rules.split(','));
            }, []);

            this.opts.proxyBypass = proxyBypass;
        }
    }

    // API
    embeddingOptions(opts) {
        this._registerAssets(opts.assets);
        this.opts.TestRunCtor = opts.TestRunCtor;

        return this;
    }

    src(...sources) {
        this.bootstrapper.sources = this.bootstrapper.sources.concat((0, _lodash.flattenDeep)(sources));

        return this;
    }

    browsers(...browsers) {
        this.bootstrapper.browsers = this.bootstrapper.browsers.concat((0, _lodash.flattenDeep)(browsers));

        return this;
    }

    concurrency(concurrency) {
        this.bootstrapper.concurrency = concurrency;

        return this;
    }

    reporter(name, outStream) {
        this.bootstrapper.reporters.push({
            name,
            outStream
        });

        return this;
    }

    filter(filter) {
        this.bootstrapper.filter = filter;

        return this;
    }

    useProxy(externalProxyHost, proxyBypass) {
        this.opts.externalProxyHost = externalProxyHost;
        this.opts.proxyBypass = proxyBypass;

        return this;
    }

    screenshots(path, takeOnFails = false, pattern = null) {
        this.opts.takeScreenshotsOnFails = takeOnFails;
        this.opts.screenshotPath = path;
        this.opts.screenshotPathPattern = pattern;

        return this;
    }

    startApp(command, initDelay) {
        this.bootstrapper.appCommand = command;
        this.bootstrapper.appInitDelay = initDelay;

        return this;
    }

    run({ skipJsErrors, disablePageReloads, quarantineMode, debugMode, selectorTimeout, assertionTimeout, pageLoadTimeout, speed = 1, debugOnFail } = {}) {
        this.opts.skipJsErrors = !!skipJsErrors;
        this.opts.disablePageReloads = !!disablePageReloads;
        this.opts.quarantineMode = !!quarantineMode;
        this.opts.debugMode = !!debugMode;
        this.opts.debugOnFail = !!debugOnFail;
        this.opts.selectorTimeout = selectorTimeout === void 0 ? DEFAULT_SELECTOR_TIMEOUT : selectorTimeout;
        this.opts.assertionTimeout = assertionTimeout === void 0 ? DEFAULT_ASSERTION_TIMEOUT : assertionTimeout;
        this.opts.pageLoadTimeout = pageLoadTimeout === void 0 ? DEFAULT_PAGE_LOAD_TIMEOUT : pageLoadTimeout;

        this.opts.speed = speed;

        var runTaskPromise = _pinkie2.default.resolve().then(() => {
            this._validateRunOptions();

            return this.bootstrapper.createRunnableConfiguration();
        }).then(({ reporterPlugins, browserSet, tests, testedApp }) => {
            this.emit('done-bootstrapping');

            return this._runTask(reporterPlugins, browserSet, tests, testedApp);
        });

        return this._createCancelablePromise(runTaskPromise);
    }

    stop() {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // NOTE: When taskPromise is cancelled, it is removed from
            // the pendingTaskPromises array, which leads to shifting indexes
            // towards the beginning. So, we must copy the array in order to iterate it,
            // or we can perform iteration from the end to the beginning.
            var cancellationPromises = (0, _mapReverse2.default)(_this.pendingTaskPromises, function (taskPromise) {
                return taskPromise.cancel();
            });

            yield _pinkie2.default.all(cancellationPromises);
        })();
    }
}
exports.default = Runner;
module.exports = exports['default'];
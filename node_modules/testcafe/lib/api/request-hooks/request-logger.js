'use strict';

exports.__esModule = true;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

exports.default = createRequestLogger;

var _testcafeHammerhead = require('testcafe-hammerhead');

var _hook = require('./hook');

var _hook2 = _interopRequireDefault(_hook);

var _useragent = require('useragent');

var _testRunTracker = require('../test-run-tracker');

var _testRunTracker2 = _interopRequireDefault(_testRunTracker);

var _reExecutablePromise = require('../../utils/re-executable-promise');

var _reExecutablePromise2 = _interopRequireDefault(_reExecutablePromise);

var _runtime = require('../../errors/runtime');

var _message = require('../../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_OPTIONS = {
    logRequestHeaders: false,
    logRequestBody: false,
    stringifyRequestBody: false,
    logResponseHeaders: false,
    logResponseBody: false,
    stringifyResponseBody: false
};

class RequestLoggerImplementation extends _hook2.default {
    constructor(requestFilterRuleInit, options) {
        options = (0, _assign2.default)({}, DEFAULT_OPTIONS, options);
        RequestLoggerImplementation._assertLogOptions(options);

        const configureResponseEventOptions = new _testcafeHammerhead.ConfigureResponseEventOptions(options.logResponseHeaders, options.logResponseBody);

        super(requestFilterRuleInit, configureResponseEventOptions);

        this.options = options;

        this._internalRequests = {};
    }

    static _assertLogOptions(logOptions) {
        if (!logOptions.logRequestBody && logOptions.stringifyRequestBody) throw new _runtime.APIError('RequestLogger', _message2.default.requestHookConfigureAPIError, 'RequestLogger', 'Cannot stringify the request body because it is not logged. Specify { logRequestBody: true } in log options.');

        if (!logOptions.logResponseBody && logOptions.stringifyResponseBody) throw new _runtime.APIError('RequestLogger', _message2.default.requestHookConfigureAPIError, 'RequestLogger', 'Cannot stringify the response body because it is not logged. Specify { logResponseBody: true } in log options.');
    }

    onRequest(event) {
        const userAgent = (0, _useragent.parse)(event._requestInfo.userAgent).toString();

        const loggedReq = {
            id: event._requestInfo.requestId,
            testRunId: event._requestInfo.sessionId,
            userAgent,
            request: {
                url: event._requestInfo.url,
                method: event._requestInfo.method
            }
        };

        if (this.options.logRequestHeaders) loggedReq.request.headers = (0, _assign2.default)({}, event._requestInfo.headers);

        if (this.options.logRequestBody) loggedReq.request.body = this.options.stringifyRequestBody ? event._requestInfo.body.toString() : event._requestInfo.body;

        this._internalRequests[loggedReq.id] = loggedReq;
    }

    onResponse(event) {
        const loggerReq = this._internalRequests[event.requestId];

        // NOTE: If the 'clear' method is called during a long running request,
        // we should not save a response part - request part has been already removed.
        if (!loggerReq) return;

        loggerReq.response = {};
        loggerReq.response.statusCode = event.statusCode;

        if (this.options.logResponseHeaders) loggerReq.response.headers = (0, _assign2.default)({}, event.headers);

        if (this.options.logResponseBody) loggerReq.response.body = this.options.stringifyResponseBody ? event.body.toString() : event.body;
    }

    _prepareInternalRequestInfo() {
        const testRun = _testRunTracker2.default.resolveContextTestRun();
        let preparedRequests = (0, _values2.default)(this._internalRequests);

        if (testRun) preparedRequests = preparedRequests.filter(r => r.testRunId === testRun.id);

        return preparedRequests;
    }

    _getCompletedRequests() {
        return this._prepareInternalRequestInfo().filter(r => r.response);
    }

    // API
    contains(predicate) {
        var _this = this;

        return _reExecutablePromise2.default.fromFn((0, _asyncToGenerator3.default)(function* () {
            return !!_this._getCompletedRequests().find(predicate);
        }));
    }

    count(predicate) {
        var _this2 = this;

        return _reExecutablePromise2.default.fromFn((0, _asyncToGenerator3.default)(function* () {
            return _this2._getCompletedRequests().filter(predicate).length;
        }));
    }

    clear() {
        const testRun = _testRunTracker2.default.resolveContextTestRun();

        if (testRun) {
            (0, _keys2.default)(this._internalRequests).forEach(id => {
                if (this._internalRequests[id].testRunId === testRun.id) delete this._internalRequests[id];
            });
        } else this._internalRequests = {};
    }

    get requests() {
        return this._prepareInternalRequestInfo();
    }
}

function createRequestLogger(requestFilterRuleInit, logOptions) {
    return new RequestLoggerImplementation(requestFilterRuleInit, logOptions);
}
module.exports = exports['default'];